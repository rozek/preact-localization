{"version":3,"file":"preact-localization.esm.js","sources":["../src/components/provider.js","../src/lib/translate.js","../src/lib/template.js","../src/components/text.js","../src/lib/util.js","../src/components/localizer.js","../src/lib/translate-mapping.js","../src/components/markup-text.js"],"sourcesContent":["import { h, createContext } from 'preact'\n\nexport const Context = createContext()\n\nexport const IntlProvider = ({ children, dictionary }) => (\n  <Context.Provider value={dictionary}>{children}</Context.Provider>\n)\n","import dlv from 'dlv'\nimport template from './template'\n\nexport default function translate(\n  id,\n  dictionary,\n  fields,\n  plural,\n  fallback = null\n) {\n  let value = dictionary && id && dlv(dictionary, id)\n\n  if ((plural || plural === 0) && value && typeof value === 'object') {\n    if (plural === 0) {\n      value = value.none\n    } else if (plural === 1) {\n      value = value.one\n    } else {\n      value = value.many\n    }\n  }\n\n  return (value && template(value, fields)) || fallback\n}\n","import dlv from 'dlv'\n\nexport default function template(string, fields) {\n  return (\n    string &&\n    string.replace(/\\{\\{([\\w.-]+)\\}\\}/g, (_, field) => {\n      let value = dlv(fields, field)\n      if (value == null) {\n        return ''\n      }\n\n      // Allow for recursive {{config.xx}} references:\n      if (typeof value === 'string' && value.match(/\\{\\{/)) {\n        value = template(value, fields)\n      }\n\n      return value\n    })\n  )\n}\n","import { h } from 'preact'\nimport translate from '../lib/translate'\nimport { Context } from './provider'\n\nexport const Text = ({ id, children, plural, fields }) => (\n  <Context.Consumer>\n    {dictionary => translate(id, dictionary, fields, plural, children)}\n  </Context.Consumer>\n)\n","export function escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  }\n\n  return text.replace(/[&<>\"']/g, m => map[m])\n}\n","import { h, cloneElement, toChildArray } from 'preact'\nimport translateMapping from '../lib/translate-mapping'\nimport { Context } from './provider'\n\nexport const Localizer = ({ children }) => (\n  <Context.Consumer>\n    {dictionary =>\n      toChildArray(children).map(child =>\n        cloneElement(child, translateMapping(child.props, dictionary))\n      )\n    }\n  </Context.Consumer>\n)\n","import translate from './translate'\nimport { Text } from '../components/text'\n\nexport default function translateMapping(props, dictionary) {\n  const out = {}\n\n  for (const name in props) {\n    if (props.hasOwnProperty(name) && props[name]) {\n      const def = props[name]\n\n      if (def.type === Text) {\n        const { props } = def\n        out[name] = translate(\n          props.id,\n          dictionary,\n          props.fields,\n          props.plural,\n          props.children\n        )\n      }\n    }\n  }\n\n  return out\n}\n","import { h } from 'preact'\nimport { escapeHtml } from '../lib/util'\nimport { Text } from './text'\nimport { Localizer } from './localizer'\n\nfunction Markup({ as, text, ...props }) {\n  if (!text) {\n    return text\n  }\n\n  const Element = as || 'span'\n  return typeof text === 'string' ? (\n    <Element\n      {...props}\n      dangerouslySetInnerHTML={{ __html: text.replace(/\\n/g, '<br/>') }}\n    />\n  ) : (\n    <Element>{text}</Element>\n  )\n}\n\nexport function MarkupText({ as, class: className, fields, ...props }) {\n  for (let key in fields) {\n    fields[key] = escapeHtml(new String(fields[key]))\n  }\n\n  return (\n    <Localizer>\n      <Markup\n        as={as}\n        class={className}\n        text={<Text {...props} fields={fields} />}\n      />\n    </Localizer>\n  )\n}\n"],"names":["const","Context","createContext","IntlProvider","h","Provider","value","translate","id","dictionary","fields","plural","fallback","let","dlv","none","one","many","template","string","replace","_","field","match","Text","Consumer","children","escapeHtml","text","map","&","<",">","\"","'","m","Localizer","toChildArray","child","cloneElement","props","out","name","hasOwnProperty","def","type","translateMapping","Markup","Element","as","dangerouslySetInnerHTML","__html","MarkupText","key","String","class","className"],"mappings":"qGAEOA,IAAMC,EAAUC,IAEVC,qBACXC,EAACH,EAAQI,UAASC,iCCFL,SAASC,EACtBC,EACAC,EACAC,EACAC,EACAC,kBAAW,MAEXC,IAAIP,EAAQG,GAAcD,GAAMM,EAAIL,EAAYD,GAYhD,OAVKG,GAAqB,IAAXA,IAAiBL,GAA0B,iBAAVA,IAE5CA,EADa,IAAXK,EACML,EAAMS,KACM,IAAXJ,EACDL,EAAMU,IAENV,EAAMW,MAIVX,GCpBK,SAASY,EAASC,EAAQT,GACvC,OACES,GACAA,EAAOC,QAAQ,8BAAuBC,EAAGC,GACvCT,IAAIP,EAAQQ,EAAIJ,EAAQY,GACxB,OAAa,MAAThB,EACK,IAIY,iBAAVA,GAAsBA,EAAMiB,MAAM,UAC3CjB,EAAQY,EAASZ,EAAOI,IAGnBJ,KDMMY,CAASZ,EAAOI,IAAYE,MElBlCY,mEACXpB,EAACH,EAAQwB,uBACNhB,UAAcF,EAAUC,EAAIC,EAAYC,EAAQC,EAAQe,MCNtD,SAASC,EAAWC,GACzB5B,IAAM6B,EAAM,CACVC,IAAK,QACLC,IAAK,OACLC,IAAK,OACLC,IAAK,SACLC,IAAK,UAGP,OAAON,EAAKR,QAAQ,oBAAYe,UAAKN,EAAIM,SCL9BC,sCACXhC,EAACH,EAAQwB,uBACNhB,UACC4B,EAAaX,GAAUG,aAAIS,UACzBC,EAAaD,ECLN,SAA0BE,EAAO/B,GAC9CT,IAAMyC,EAAM,GAEZ,IAAKzC,IAAM0C,KAAQF,EACjB,GAAIA,EAAMG,eAAeD,IAASF,EAAME,GAAO,CAC7C1C,IAAM4C,EAAMJ,EAAME,GAElB,GAAIE,EAAIC,OAASrB,EAAM,CACbgB,cACRC,EAAIC,GAAQnC,EACViC,EAAMhC,GACNC,EACA+B,EAAM9B,OACN8B,EAAM7B,OACN6B,EAAMd,WAMd,OAAOe,EDfmBK,CAAiBR,EAAME,MAAO/B,oIEH1D,SAASsC,8CACP,IAAKnB,EACH,OAAOA,EAGT5B,IAAMgD,EAAUC,GAAM,OACtB,MAAuB,iBAATrB,EACZxB,EAAC4C,sBAECE,wBAAyB,CAAEC,OAAQvB,EAAKR,QAAQ,MAAO,aAGzDhB,EAAC4C,OAASpB,GAIP,SAASwB,oEACd,IAAKvC,IAAIwC,KAAO3C,EACdA,EAAO2C,GAAO1B,EAAW,IAAI2B,OAAO5C,EAAO2C,KAG7C,OACEjD,EAACgC,OACChC,EAAC2C,GACCE,GAAIA,EACJM,MAAOC,EACP5B,KAAMxB,EAACoB,mBAASgB,GAAO9B,OAAQA"}
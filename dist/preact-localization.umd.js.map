{"version":3,"file":"preact-localization.umd.js","sources":["../src/components/provider.js","../src/lib/translate.js","../src/lib/template.js","../src/components/text.js","../src/lib/util.js","../src/components/localizer.js","../src/lib/translate-mapping.js","../src/components/markup-text.js"],"sourcesContent":["import { h, createContext } from 'preact'\n\nexport const Context = createContext()\n\nexport const IntlProvider = ({ children, dictionary }) => (\n  <Context.Provider value={dictionary}>{children}</Context.Provider>\n)\n","import dlv from 'dlv'\nimport template from './template'\n\nexport default function translate(\n  id,\n  dictionary,\n  fields,\n  plural,\n  fallback = null\n) {\n  let value = dictionary && id && dlv(dictionary, id)\n\n  if ((plural || plural === 0) && value && typeof value === 'object') {\n    if (plural === 0) {\n      value = value.none\n    } else if (plural === 1) {\n      value = value.one\n    } else {\n      value = value.many\n    }\n  }\n\n  return (value && template(value, fields)) || fallback\n}\n","import dlv from 'dlv'\n\nexport default function template(string, fields) {\n  return (\n    string &&\n    string.replace(/\\{\\{([\\w.-]+)\\}\\}/g, (_, field) => {\n      let value = dlv(fields, field)\n      if (value == null) {\n        return ''\n      }\n\n      // Allow for recursive {{config.xx}} references:\n      if (typeof value === 'string' && value.match(/\\{\\{/)) {\n        value = template(value, fields)\n      }\n\n      return value\n    })\n  )\n}\n","import { h } from 'preact'\nimport translate from '../lib/translate'\nimport { Context } from './provider'\n\nexport const Text = ({ id, children, plural, fields }) => (\n  <Context.Consumer>\n    {dictionary => translate(id, dictionary, fields, plural, children)}\n  </Context.Consumer>\n)\n","export function escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  }\n\n  return text.replace(/[&<>\"']/g, m => map[m])\n}\n","import { h, cloneElement, toChildArray } from 'preact'\nimport translateMapping from '../lib/translate-mapping'\nimport { Context } from './provider'\n\nexport const Localizer = ({ children }) => (\n  <Context.Consumer>\n    {dictionary =>\n      toChildArray(children).map(child =>\n        cloneElement(child, translateMapping(child.props, dictionary))\n      )\n    }\n  </Context.Consumer>\n)\n","import translate from './translate'\nimport { Text } from '../components/text'\n\nexport default function translateMapping(props, dictionary) {\n  const out = {}\n\n  for (const name in props) {\n    if (props.hasOwnProperty(name) && props[name]) {\n      const def = props[name]\n\n      if (def.type === Text) {\n        const { props } = def\n        out[name] = translate(\n          props.id,\n          dictionary,\n          props.fields,\n          props.plural,\n          props.children\n        )\n      }\n    }\n  }\n\n  return out\n}\n","import { h } from 'preact'\nimport { escapeHtml } from '../lib/util'\nimport { Text } from './text'\nimport { Localizer } from './localizer'\n\nfunction Markup({ as, text, ...props }) {\n  if (!text) {\n    return text\n  }\n\n  const Element = as || 'span'\n  return typeof text === 'string' ? (\n    <Element\n      {...props}\n      dangerouslySetInnerHTML={{ __html: text.replace(/\\n/g, '<br/>') }}\n    />\n  ) : (\n    <Element>{text}</Element>\n  )\n}\n\nexport function MarkupText({ as, class: className, fields, ...props }) {\n  for (let key in fields) {\n    fields[key] = escapeHtml(new String(fields[key]))\n  }\n\n  return (\n    <Localizer>\n      <Markup\n        as={as}\n        class={className}\n        text={<Text {...props} fields={fields} />}\n      />\n    </Localizer>\n  )\n}\n"],"names":["const","Context","createContext","translate","id","dictionary","fields","plural","fallback","let","value","dlv","none","one","many","template","string","replace","_","field","match","Text","h","Consumer","children","escapeHtml","text","map","&","<",">","\"","'","m","Localizer","toChildArray","child","cloneElement","props","out","name","hasOwnProperty","def","type","translateMapping","Markup","Element","as","dangerouslySetInnerHTML","__html","Provider","key","String","class","className"],"mappings":"wSAEOA,IAAMC,EAAUC,kBCCR,SAASC,EACtBC,EACAC,EACAC,EACAC,EACAC,kBAAW,MAEXC,IAAIC,EAAQL,GAAcD,GAAMO,EAAIN,EAAYD,GAYhD,OAVKG,GAAqB,IAAXA,IAAiBG,GAA0B,iBAAVA,IAE5CA,EADa,IAAXH,EACMG,EAAME,KACM,IAAXL,EACDG,EAAMG,IAENH,EAAMI,MAIVJ,GCpBK,SAASK,EAASC,EAAQV,GACvC,OACEU,GACAA,EAAOC,QAAQ,8BAAuBC,EAAGC,GACvCV,IAAIC,EAAQC,EAAIL,EAAQa,GACxB,OAAa,MAATT,EACK,IAIY,iBAAVA,GAAsBA,EAAMU,MAAM,UAC3CV,EAAQK,EAASL,EAAOJ,IAGnBI,KDMMK,CAASL,EAAOJ,IAAYE,MElBlCa,mEACXC,IAACrB,EAAQsB,uBACNlB,UAAcF,EAAUC,EAAIC,EAAYC,EAAQC,EAAQiB,MCNtD,SAASC,EAAWC,GACzB1B,IAAM2B,EAAM,CACVC,IAAK,QACLC,IAAK,OACLC,IAAK,OACLC,IAAK,SACLC,IAAK,UAGP,OAAON,EAAKT,QAAQ,oBAAYgB,UAAKN,EAAIM,SCL9BC,sCACXZ,IAACrB,EAAQsB,uBACNlB,UACC8B,eAAaX,GAAUG,aAAIS,UACzBC,eAAaD,ECLN,SAA0BE,EAAOjC,GAC9CL,IAAMuC,EAAM,GAEZ,IAAKvC,IAAMwC,KAAQF,EACjB,GAAIA,EAAMG,eAAeD,IAASF,EAAME,GAAO,CAC7CxC,IAAM0C,EAAMJ,EAAME,GAElB,GAAIE,EAAIC,OAAStB,EAAM,CACbiB,cACRC,EAAIC,GAAQrC,EACVmC,EAAMlC,GACNC,EACAiC,EAAMhC,OACNgC,EAAM/B,OACN+B,EAAMd,WAMd,OAAOe,EDfmBK,CAAiBR,EAAME,MAAOjC,oIEH1D,SAASwC,8CACP,IAAKnB,EACH,OAAOA,EAGT1B,IAAM8C,EAAUC,GAAM,OACtB,MAAuB,iBAATrB,EACZJ,IAACwB,sBAECE,wBAAyB,CAAEC,OAAQvB,EAAKT,QAAQ,MAAO,aAGzDK,IAACwB,OAASpB,qCPZZJ,IAACrB,EAAQiD,UAASxC,uDOgBb,2EACL,IAAKD,IAAI0C,KAAO7C,EACdA,EAAO6C,GAAO1B,EAAW,IAAI2B,OAAO9C,EAAO6C,KAG7C,OACE7B,IAACY,OACCZ,IAACuB,GACCE,GAAIA,EACJM,MAAOC,EACP5B,KAAMJ,IAACD,mBAASiB,GAAOhC,OAAQA"}